type InterfaceMap = {
  [name: string]: string;
};

export class TypeGenerator {
  private generatedInterfaces: InterfaceMap = {};

  generate(data: any, interfaceName = "AutoGenerated"): string {
    this.generatedInterfaces = {};
    this.processData(data, interfaceName);
    return this.formatInterfaces(interfaceName);
  }

  private processData(data: any, interfaceName: string): string {
    // Handle special types first
    if (data instanceof Date) return "Date";
    if (data?.constructor?.name === "ObjectId") return "string";

    if (Array.isArray(data)) {
      return this.processArray(data, interfaceName);
    }
    if (typeof data === "object" && data !== null) {
      return this.processObject(data, interfaceName);
    }
    return typeof data;
  }

  private processArray(arr: any[], parentName: string): string {
    if (arr.length === 0) return "any[]";
    const elementType = this.processData(arr[0], parentName);
    return `${elementType}[]`;
  }

  private processObject(obj: object, interfaceName: string): string {
    const signature = this.getObjectSignature(obj);
    if (this.generatedInterfaces[signature]) {
      return this.generatedInterfaces[signature];
    }

    const interfaceBody = Object.entries(obj)
      .map(([key, value]) => {
        const type = this.processData(
          value,
          `${interfaceName}${this.capitalize(key)}`
        );
        return `${key}: ${type};`;
      })
      .join("\n  ");

    const interfaceCode = `interface ${interfaceName} {\n  ${interfaceBody}\n}`;
    this.generatedInterfaces[signature] = interfaceName;
    this.generatedInterfaces[interfaceName] = interfaceCode;
    return interfaceName;
  }

  private getObjectSignature(obj: object): string {
    return Object.entries(obj)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => {
        const type = typeof value;
        return `${key}:${Array.isArray(value) ? "array" : type}`;
      })
      .join(",");
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private formatInterfaces(rootName: string): string {
    const interfaces = Object.values(this.generatedInterfaces)
      .filter((v) => v.includes("interface"))
      .reverse();

    const mainInterface =
      interfaces.find((i) => i.startsWith(`interface ${rootName}`)) ||
      `interface ${rootName} {}`;

    const typeExports = [
      ...interfaces.filter((i) => !i.startsWith(`interface ${rootName}`)),
      mainInterface,
    ].join("\n\n");

    return `${typeExports}\n\nexport { ${rootName} };`;
  }
}
