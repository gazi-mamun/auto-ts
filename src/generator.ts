type InterfaceMap = {
  [name: string]: string;
};

export class TypeGenerator {
  private generatedInterfaces: InterfaceMap = {};
  private usedInterfaceNames: Set<string> = new Set(); // Track used names

  generate(data: any, interfaceName = 'AutoGenerated'): string {
    this.generatedInterfaces = {};
    this.usedInterfaceNames.clear();
    this.processData(data, interfaceName);
    return this.formatInterfaces(interfaceName);
  }

  private processData(data: any, interfaceName: string): string {
    if (data instanceof Date) return 'Date';
    if (data?.constructor?.name === 'ObjectId') return 'string';

    if (Array.isArray(data)) {
      return this.processArray(data, interfaceName);
    }
    if (typeof data === 'object' && data !== null) {
      return this.processObject(data, interfaceName);
    }
    return typeof data;
  }

  private processArray(arr: any[], parentName: string): string {
    if (arr.length === 0) return 'any[]';
    const elementType = this.processData(arr[0], parentName);
    return `${elementType}[]`;
  }

  private processObject(obj: object, interfaceName: string): string {
    // Generate a unique signature for nested objects
    const signature = this.getObjectSignature(obj, interfaceName);

    if (this.generatedInterfaces[signature]) {
      return this.generatedInterfaces[signature];
    }

    let uniqueName = interfaceName;
    let counter = 1;
    // Ensure unique interface names
    while (this.usedInterfaceNames.has(uniqueName)) {
      uniqueName = `${interfaceName}_${counter++}`;
    }
    this.usedInterfaceNames.add(uniqueName);

    const interfaceBody = Object.entries(obj)
      .map(([key, value]) => {
        const type = this.processData(
          value,
          `${uniqueName}${this.capitalize(key)}`,
        );
        return `${key}: ${type};`;
      })
      .join('\n  ');

    const interfaceCode = `interface ${uniqueName} {\n  ${interfaceBody}\n}`;
    this.generatedInterfaces[signature] = uniqueName;
    this.generatedInterfaces[uniqueName] = interfaceCode;
    return uniqueName;
  }

  // Generate a recursive signature for nested objects
  private getObjectSignature(obj: object, parentName: string): string {
    return Object.entries(obj)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => {
        let type: string;
        if (Array.isArray(value)) {
          type = `array:${this.processData(value[0] || {}, `${parentName}${this.capitalize(key)}`)}`;
        } else if (typeof value === 'object' && value !== null) {
          type = `object:${this.getObjectSignature(value, `${parentName}${this.capitalize(key)}`)}`;
        } else {
          type = typeof value;
        }
        return `${key}:${type}`;
      })
      .join(',');
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private formatInterfaces(rootName: string): string {
    // Include ALL generated interfaces
    return (
      Object.values(this.generatedInterfaces)
        .filter((v) => v.includes('interface'))
        .reverse()
        .join('\n\n') + `\n\nexport { ${rootName} };`
    );
  }
}
